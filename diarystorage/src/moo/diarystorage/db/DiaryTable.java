package moo.diarystorage.db;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.LinkedList;
import java.util.List;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * should be auto generated by ORM
 */
public class DiaryTable {

    public static class Row {

        public static Row fromResultSet(ResultSet resultSet) throws SQLException {
            Row row = new Row();
            row.id = resultSet.getLong(1);
            row.title = resultSet.getString(2);
            row.content = resultSet.getString(3);
            row.authorId = resultSet.getLong(4);
            row.tags = resultSet.getString(5);
            row.createTime = resultSet.getString(6);
            row.modifyTime = resultSet.getString(7);
            return row;
        }

        public long id = -1;

        public String title;

        public String content;

        public String tags;

        public long authorId;

        public String createTime;

        public String modifyTime;
    }

    private static final Logger LOGGER = LoggerFactory.getLogger(DiaryTable.class);

    private static final String TABLE_NAME = "diary_table";

    static {
        createTableIfNotExists();
    }

    private static int createTableIfNotExists() {
        String sql = "CREATE TABLE IF NOT EXISTS " + TABLE_NAME + " ("
                + "id LONG PRIMARY KEY," // a.k.a row id by sqlite
                + "title TEXT NOT NULL DEFAULT \"\","
                + "content TEXT NOT NULL DEFAULT \"\","
                + "author_id LONG NOT NULL,"
                + "tags TEXT NOT NULL DEFAULT \"\","
                + "create_time TEXT NOT NULL DEFAULT(strftime('%Y-%m-%d %H:%M:%f +0000', 'now')),"
                + "modify_time TEXT NOT NULL DEFAULT(strftime('%Y-%m-%d %H:%M:%f +0000', 'now'))"
                + ");";
        try (Connection conn = SqliteHelper.getConnection();
                PreparedStatement ps = conn.prepareStatement(sql)) {
            return ps.executeUpdate();
        } catch (SQLException e) {
            LOGGER.error(e.getMessage());
        }
        return 0;
    }

    static int insert(String title, String content, long authorId, String tags, String createTime,
            String modifyTime) {
        String sql = String.format(
                "INSERT INTO %s (title, content, author_id, tags, create_time, modify_time) VALUES (?, ?, ?, ?, ?, ?)",
                TABLE_NAME);
        try (Connection conn = SqliteHelper.getConnection();
                PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setString(1, title);
            ps.setString(2, content);
            ps.setLong(3, authorId);
            ps.setString(4, tags);
            ps.setString(5, createTime);
            ps.setString(6, modifyTime);
            return ps.executeUpdate();
        } catch (SQLException e) {
            LOGGER.error(e.getMessage());
        }
        return 0;
    }

    public static int insertOrUpdate(long id, String title, String content, long authorId,
            String tags, String createTime, String modifyTime) {
        if (id < 0) {
            return insert(title, content, authorId, tags, createTime, modifyTime);
        }

        String sql = String.format(
                "INSERT OR REPLACE INTO %s (id, title, content, author_id, tags, create_time, modify_time) VALUES (?, ?, ?, ?, ?, ?, ?)",
                TABLE_NAME);
        try (Connection conn = SqliteHelper.getConnection();
                PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setLong(1, id);
            ps.setString(2, title);
            ps.setString(3, content);
            ps.setLong(4, authorId);
            ps.setString(5, tags);
            ps.setString(6, createTime);
            ps.setString(7, modifyTime);
            return ps.executeUpdate();
        } catch (SQLException e) {
            LOGGER.error(e.getMessage());
        }
        return 0;
    }

    public static int insertOrUpdate(Row row) {
        return insertOrUpdate(row.id, row.title, row.content, row.authorId, row.tags,
                row.createTime, row.modifyTime);
    }

    public static int remove(long id) {
        String sql = String.format(
                "DELETE FROM %s WHERE id=?",
                TABLE_NAME);
        try (Connection conn = SqliteHelper.getConnection();
                PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setLong(1, id);
            return ps.executeUpdate();
        } catch (SQLException e) {
            LOGGER.error(e.getMessage());
        }
        return 0;
    }

    public static List<Row> select(long id) {
        List<Row> rows = new LinkedList<>();
        String sql = String.format(
                "SELECT * FROM %s WHERE id=?",
                TABLE_NAME);
        try (Connection conn = SqliteHelper.getConnection();
                PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setLong(1, id);
            ResultSet resultSet = ps.executeQuery();
            while (resultSet.next()) {
                Row row = Row.fromResultSet(resultSet);
                rows.add(row);
            }
        } catch (SQLException e) {
            LOGGER.error(e.getMessage());
        }
        return rows;
    }

    public static List<Row> selectByAuthorId(long authorId) {
        return selectByAuthorId(authorId, 99, 0);
    }

    public static List<Row> selectByAuthorId(long authorId, int limit, int start) {
        List<Row> rows = new LinkedList<>();
        String sql = String.format(
                "SELECT * FROM %s WHERE author_id=? ORDER BY create_time DESC LIMIT ? OFFSET ?",
                TABLE_NAME);
        try (Connection conn = SqliteHelper.getConnection();
                PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setLong(1, authorId);
            ps.setInt(2, limit);
            ps.setInt(3, start);
            ResultSet resultSet = ps.executeQuery();
            while (resultSet.next()) {
                Row row = Row.fromResultSet(resultSet);
                rows.add(row);
            }
        } catch (SQLException e) {
            LOGGER.error(e.getMessage());
        }
        return rows;
    }
}
